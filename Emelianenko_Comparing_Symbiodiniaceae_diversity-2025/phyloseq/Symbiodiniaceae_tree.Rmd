---
title: "Symbiodiniaceae phyloseq tree"
author: "Vera Emelianenko"
date: "`r Sys.Date()`"
output: html_document
---
This is the R code for generating Symbiodiniaceae ASVs phylogenetic trees used further for phyloseq objects.

Main selected approach uses FastTree. We additionally tested two other approaches, both creating a Neighbor-Joining tree based on a set of distances. First approach is a hybrid tree based on between genera distances approximated from 28S rRNA Maximum Likelihood tree and intra-genera distances calculated as pairwise distances between ITS2 sequences using identity [3]. Second approach is based on k-mer distances between ITS2 sequences. Both approaches gave comparable results but tended to distort between genera relationships when highly divergent sequences were present, while FastTree preserved plausible genera relationship even on unfiltered data. The k-mer tree emphasized variation between the sequences the most, while tree generated by FastTree reduced this variation.

Tree visualisation with ggtree and troubleshooting were assisted by ChatGPT (GPT-5, OpenAI).

```{r setup, include=FALSE}

# function to load the packages and install if not installed
load_packages <- function(package_name)
  {
    if (!require(package_name, character.only = TRUE)) 
    {
      install.packages(package_name)
      library(package_name, character.only = TRUE)
    }
    else
    {
      library(package_name, character.only = TRUE)
    }
        
  }

# change the name of required packages
Packages = c(
  "magrittr",      # to use %>%
  "data.table",    # to read tables 
  "tidyverse",     # dplyr, tidyr, stringr, forcats, ggplot2
  "seqinr",        # for read.alignment()
  "phyloseq",      # handling microbiome data objects
  "microbiome",    # transformations like Hellinger
  "DECIPHER",      # sequence alignment (AlignSeqs)
  "Biostrings",    # DNAStringSet operations
  "ape",           # phylogenetics: dist.alignment, write.tree
  "phangorn",      # phylogenetics: UPGMA trees, making combined 28S tree
  "ggtree",         # visualise phylogenetic trees
  "reshape2",      # melt, acast
  "kmer",          # k-mer distances
  "dendextend",    # compare trees with tanglegram
  "scales",        # percentage axis labels
  "ggsci",         # color palettes (pal_d3)
  "ggalt" #,         # geom_encircle
  #"patchwork",     # combine plots
  #"picante",        # for Faith FD
  #"vegan",         # ecological analyses (ordination, distances)
  #"pairwiseAdonis" # PERMANOVA pairwise comparisons
)

invisible(lapply(Packages, load_packages))


#if (!require("BiocManager", quietly = TRUE))
    #install.packages("BiocManager")
# BiocManager::install("ggtree")

# Setup knitr defaults with standard formatting changes
knitr::opts_chunk$set(echo=T, message=F, eval=T, fig.show="markup", include=T, warning=F, results="markup", tidy=T)

options(scipen=999) # disable scientific notation when displaying numbers

#  Empty workspace
 rm(list=ls())
```

Copy the files 
```{r}
source("../shared_settings.R") # Define color palettes, order of samples, theme

files_to_copy <- c(
  "../dada2_assign_taxonomy/output/ASV_counts_Symbiodiniaceae_filtered.tsv",    # otu table filtered 
  "../dada2_assign_taxonomy/output/ASV_Symbiodiniaceae_filtered.fasta",         # fasta file filtered 
  "../dada2_assign_taxonomy/output/ASV_tax_Symbiodiniaceae_filtered.tsv",       # tax table filtered 
  "../barplots_heatmap/output/symportal_meta_df.tsv",                           # metadata 
  "../dada2_assign_taxonomy/output/ASV_counts_Symbiodiniaceae_unfiltered.tsv",  # otu table raw 
  "../dada2_assign_taxonomy/output/ASV_tax_Symbiodiniaceae_unfiltered.tsv",     # tax table raw
  "../dada2_assign_taxonomy/output/ASV_Symbiodiniaceae_unfiltered.fasta",       # fasta raw
  "../dada2_assign_taxonomy/output/ASV_tax_Symbiodiniaceae_prelulu.tsv",        # before lulu tax table
  "../dada2_assign_taxonomy/output/ASVs_counts_Sym_prelulu.tsv",                # before lulu otu table
  "../dada2_assign_taxonomy/output/ASV_Symbiodiniaceae_prelulu.fasta"           # before lulu fasta
)

# define the destination folder (current folder = "./")
dest_folder <- "./input"

# copy files
success <- file.copy(from = files_to_copy, to = dest_folder, overwrite = TRUE)

# check which files copied successfully
data.frame(
  file = basename(files_to_copy),
  copied = success
)
```

Create a phyloseq object (workflow to create an object from https://vaulot.github.io/tutorials/Phyloseq_tutorial.html ).

Need: 
- otu table (each row is an otu, each column is a sample) - ASV
- tax table (each row is an otu, each column is a taxonomic rank (phylum, order ... species)) - ASV
- samples table (metadata: each row is a sample, each column a separate metadata such as type, site, etc)
# Create phyloseq object 
```{r}
# read the data 
asv_mat <- data.table::fread('./input/ASV_counts_Symbiodiniaceae_filtered.tsv') 
tax_mat <- data.table::fread("./input/ASV_tax_Symbiodiniaceae_filtered.tsv")
samples_df <-data.table::fread("./input/symportal_meta_df.tsv")
# import sequences of each ASV
dna_sequences <- Biostrings::readDNAStringSet("./input/ASV_Symbiodiniaceae_filtered.fasta")

asv_mat_raw <- data.table::fread('./input/ASV_counts_Symbiodiniaceae_unfiltered.tsv') 
tax_mat_raw <- data.table::fread("./input/ASV_tax_Symbiodiniaceae_unfiltered.tsv")
#samples_df already present 
dna_sequences_raw <- Biostrings::readDNAStringSet("./input/ASV_Symbiodiniaceae_unfiltered.fasta")

asv_mat_lulu <- data.table::fread('./input/ASVs_counts_Sym_prelulu.tsv') 
tax_mat_lulu <- data.table::fread("./input/ASV_tax_Symbiodiniaceae_prelulu.tsv")
#samples_df already present 
dna_sequences_lulu <- Biostrings::readDNAStringSet("./input/ASV_Symbiodiniaceae_prelulu.fasta")


# define row names from ASv column and same for the other two dfs
asv_mat <- asv_mat %>%    tibble::column_to_rownames("ASV") 
tax_mat <- tax_mat %>%     tibble::column_to_rownames("ASV")
samples_df <- samples_df %>%     tibble::column_to_rownames("sample_name") 
# raw: define row names from ASv column and same for the other two dfs
asv_mat_raw <- asv_mat_raw %>%    tibble::column_to_rownames("ASV") 
tax_mat_raw <- tax_mat_raw %>%     tibble::column_to_rownames("ASV")
#samples_df 
asv_mat_lulu <- asv_mat_lulu %>%  tibble::column_to_rownames("ASV") 
tax_mat_lulu <- tax_mat_lulu %>%  tibble::column_to_rownames("ASV")

# transform to matrices
asv_mat <- as.matrix(asv_mat)
tax_mat <- as.matrix(tax_mat)
#raw
asv_mat_raw <- as.matrix(asv_mat_raw)
tax_mat_raw <- as.matrix(tax_mat_raw)
#lulu
asv_mat_lulu <- as.matrix(asv_mat_lulu)
tax_mat_lulu <- as.matrix(tax_mat_lulu)

# turn into otu table and tax table
OTU = otu_table(asv_mat, taxa_are_rows = TRUE)
TAX = tax_table(tax_mat)
samples = sample_data(samples_df)
#raw
OTU_raw = otu_table(asv_mat_raw, taxa_are_rows = TRUE)
TAX_raw = tax_table(tax_mat_raw)
#samples
OTU_lulu = otu_table(asv_mat_lulu, taxa_are_rows = TRUE)
TAX_lulu = tax_table(tax_mat_lulu)


# create a phyloseq object 
phyloseq_symbio <- phyloseq(OTU, TAX, samples)
phyloseq_symbio_raw <- phyloseq(OTU_raw, TAX_raw, samples)
phyloseq_symbio_lulu <- phyloseq(OTU_lulu, TAX_lulu, samples)
sample_sums(phyloseq_symbio_lulu)

# Merge sequences into phyloseq object
phyloseq_symbio <- merge_phyloseq(phyloseq_symbio, dna_sequences)
phyloseq_symbio_raw <- merge_phyloseq(phyloseq_symbio_raw, dna_sequences_raw)
phyloseq_symbio_lulu <- merge_phyloseq(phyloseq_symbio_lulu, dna_sequences_lulu)

# check the sequences 
# refseq(symbio)[1:5]

# filter out Algae2-2
phyloseq_symbio <-subset_samples(phyloseq_symbio, sample_names(phyloseq_symbio) != "Algae2-2")
phyloseq_symbio_raw <-subset_samples(phyloseq_symbio_raw, sample_names(phyloseq_symbio_raw) != "Algae2-2")
phyloseq_symbio_lulu <-subset_samples(phyloseq_symbio_lulu, sample_names(phyloseq_symbio_lulu) != "Algae2-2")
```
Now, `phyloseq_symbio` is a phyloseq object whic has sample metadata, ASV counts, ASV sequenes, and ASV taxonomy. 

To get the distances, first get distances between the genera from 28S tree. 
```
> mafft --add ./input/Yorifuji_et_al_clade_J_28S.fasta --reorder --thread -3 input/Nitschke_et_al_LSU_S3.fasta > trees/LSU_combined_with_J.fasta

# check alignment visually and trim the sticking ends in Geneious, then export to LSU_combined_with_J_trimmed.fasta

iqtree2 -s LSU_combined_with_J_trimmed.fasta -m GTR+G+I -bb 10000 -alrt 10000 -pre LSU_J
# the model is the same as used in Fujice et al. https://onlinelibrary-wiley-com.ezproxy.oist.jp/doi/10.1111/mec.15719 
```
# Create 28S+ITS2 Frankenstein tree

### Extract the distances from the tree 
```{r}
# Read ML tree
tree <- read.tree("./trees/LSU_J.treefile")

# Compute patristic distance matrix
# calculates the cophenetic distance matrix for a given phylogenetic tree
distances <- cophenetic(tree)

# Save to file
write.table(distances, file="./trees/LSU_J_patristic_distances.txt", sep="\t", quote=FALSE)
```

Calculate mean distances between the genera
The code snippet below was modified from https://github.com/nitschkematthew/Free_living_Symbiodiniaceae_HI/blob/master/R/community_analysis/community_analysis.Rmd, with the help of ChatGPT.
```{r}
upper <- which(upper.tri(distances), arr.ind = TRUE)

distances_df <- tibble::tibble(
  label1 = rownames(distances)[upper[,1]],
  label2 = colnames(distances)[upper[,2]],
  dist   = distances[upper]
)

key_df <- read.csv("./input_manual/Key_modified.csv", header = FALSE, col.names = c("label","Genus"))

distances_renamed_df <- distances_df %>%
  left_join(key_df,  by = c("label1" = "label")) %>% dplyr::rename(Genus.x = Genus) %>%
  left_join(key_df,  by = c("label2" = "label")) %>% dplyr::rename(Genus.y = Genus)

# distances_renamed_df %>% dplyr::filter(is.na(Genus.y))
mean_distances_df <- distances_renamed_df %>%
  dplyr::group_by(Genus.x, Genus.y) %>%
  dplyr::summarise(dist = mean(dist), .groups="drop")%>%
  dplyr::filter(Genus.x != Genus.y) %>%
  dplyr::filter(Genus.x != "Outgroup", Genus.y != "Outgroup") %>% 
  dplyr::mutate(dist = 1*dist)  #1 is added because I was playing with the distance multiplication to account for shorter 28S based distances between genera

#write.table(mean_distances_df, file = "./trees/mean_distances_df.tsv", sep = "\t", quote = FALSE, row.names = FALSE)

dist_means_symmetric <- mean_distances_df %>%
  dplyr::mutate(pair = ifelse(Genus.x < Genus.y,
                              paste0(Genus.x, "_", Genus.y),
                              paste0(Genus.y, "_", Genus.x))) %>%
  dplyr::group_by(pair) %>%
  dplyr::summarise(
    Genus.x = dplyr::first(Genus.x),
    Genus.y = dplyr::first(Genus.y),
    dist = mean(dist, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  dplyr::select(Genus.x, Genus.y, dist)


write.table(dist_means_symmetric, file = "./trees/dist_means_symmetric.tsv",
            sep = "\t", quote = FALSE, row.names = FALSE)
```

Calculate distances inside the genera

The code snippet below was modified from https://github.com/nitschkematthew/Free_living_Symbiodiniaceae_HI/blob/master/R/community_analysis/community_analysis.Rmd, and comments added with the help of ChatGPT.
```{r}
# Function for subsetting phyloseq object
# Define a function that takes a phyloseq object (ps) and a genus name
generate_intragenus_dist <- function(ps, genus = "Symbiodinium"){
  taxdf <- as.data.frame(tax_table(ps)@.Data) %>%   # take taxonomy table from the phyloseq object
    tibble::rownames_to_column(var = "ASVID") %>%   # makes the rownames (sequence IDs) into a column
    filter(Genus == genus)     # keep only the genus of interest
  rownames(taxdf) <- taxdf$ASVID     # Sets the rownames back to the sequence IDs.
  taxdf$ASVID <- NULL   # remove the ASVID column
  taxdf <- as.matrix(taxdf) %>%    
    tax_table()     # make it a tax table again 
  phy_subset <- merge_phyloseq(tax_table(taxdf),
                               otu_table(ps, taxa_are_rows = FALSE),
                               refseq(ps),
                               sample_data(ps))   # make a new phyloseq object with only genus of interest
  seqs <- refseq(phy_subset)   # extract sequences 
  aligned <- AlignSeqs(seqs)  # align with AlignSeqs() (from DECIPHER package)
  #aligned is in-memory object (class DNAStringSet from the Biostrings / DECIPHER package).
  writeXStringSet(aligned, filepath = paste0("./aln/", genus, "_aligned.fasta"))  # write alignment
  aligned <- read.alignment(paste0("./aln/", genus, "_aligned.fasta"), format = "fasta")  # read alignment back into seqinr::alignment object 
  dis <- (as.matrix(dist.alignment(aligned, matrix = "identity" )))^2   # compute pairwise distances between sequences using identity (fraction of mismatches), then convert to a matrix and square
  saveRDS(dis, paste0("intra_genus_dist/", genus, "-dist.rda")) #Saves the distance matrix as an RDS file for later use.
}

# List of genera to iterate over

genera_list <- c("Symbiodinium", "Cladocopium", "Durusdinium",  "Freudenthalidium", "Fugacium", "Miliolidium",   "clade_I", "clade_J")
# "Halluxium",

# Generate intra-genus distance matrices
for(i in 1:length(genera_list)){
  print(genera_list)[i]
  generate_intragenus_dist(phyloseq_symbio, genus = genera_list[i])
}

# the distances are stored on disk, such as intra_genus_dist/Symbiodinium-dist.rda, one file per genus

# to check: 
 dis_symbio <- readRDS("intra_genus_dist/Symbiodinium-dist.rda")
 tibble::as_tibble(dis_symbio)
```

Combine the intra- and inter-genus distances and make a tree. 

The code snippet below was modified from https://github.com/nitschkematthew/Free_living_Symbiodiniaceae_HI/blob/master/R/community_analysis/community_analysis.Rmd and comments and package names added with ChatGPT.
```{r}
# Get all ASV names from the phyloseq object
ASV_list <- phyloseq::taxa_names(phyloseq_symbio)

# Create a square matrix of zeros for all ASVs
ASV_matrix <- base::matrix(0, nrow = length(ASV_list), ncol = length(ASV_list),
                           dimnames = list(ASV_list, ASV_list))

# Convert the matrix to long format for easier updates
ASV_matrix_melt <- reshape2::melt(ASV_matrix)  # this matrix only has zeros

# Load intra-genus distance paths
# drop the part of the name after dash to get the genus name from the file name with separate()
intra_dist_paths <- base::data.frame(path = base::list.files("intra_genus_dist/", pattern = "-dist")) %>%
  tidyr::separate(col = path, into = c("start"), sep = "-", extra = "drop", remove = FALSE)


# loop to update ASV_matrix_melt with intra-genus distances
for(i in seq_along(intra_dist_paths$start)){      # seq_along(intra_dist_paths$start) is just 1 2 3 4 5 6 7 8 9 
  # Load the distance matrix
  distm <- base::readRDS(paste0("intra_genus_dist/", intra_dist_paths$path[i]))   # take the first element, then second.... etc
  # Melt the matrix to long format
  meltdist <- reshape2::melt(distm)  # Melt distance matrix to long format (Var1, Var2, value).
  
  # Join onto master ASV_matrix_melt and update values
  ASV_matrix_melt <- dplyr::left_join(ASV_matrix_melt, meltdist, by = c("Var1", "Var2")) %>%  #merge into the main ASV matrix.
    dplyr::mutate(value = dplyr::case_when(   
      is.na(value.y) ~ value.x,
      TRUE ~ value.y
    )) %>%    # keep the intra-genus value if it exists, otherwise update; write to value
    dplyr::select(-value.x, -value.y) # remove columns value.x, value.y
}

# get long table from phyloseq object that has ASV (otu) and Genus
ps_long <- phyloseq::psmelt(phyloseq_symbio) %>%  # convert into a long table
  dplyr::select(OTU, Genus) %>%
  dplyr::group_by(OTU, Genus) %>%
  dplyr::distinct()  # keep only one genus per ASV

# Reverse direction table for joining
dist_means_rev <- dist_means_symmetric  %>%
  dplyr::select(Genus.y, Genus.x, dist) %>%
  dplyr::rename(Genus.x = "Genus.y", Genus.y = "Genus.x")

# Adds genus info for each ASV (Var1, Var2)
#If reversed distance exists (dist.y), use it.
#Otherwise, use the original inter-genus distance (dist.x).
#If still NA, fallback to intra-genus distance (value).

final_long_dist <- dplyr::left_join(ASV_matrix_melt, ps_long, by = c("Var1" = "OTU")) %>%
  dplyr::left_join(., ps_long, by = c("Var2" = "OTU")) %>%
  dplyr::left_join(., dist_means_symmetric, by = c("Genus.x" = "Genus.x", "Genus.y" = "Genus.y")) %>%     dplyr::rename(dist_forward = dist) %>%
  dplyr::left_join(dist_means_rev, by = c("Genus.x" = "Genus.x", "Genus.y" = "Genus.y")) %>%
  dplyr::rename(dist_reverse = dist) %>%
  dplyr::mutate(final_value = case_when(is.na(dist_reverse) ~ dist_forward, TRUE ~ dist_reverse)) %>%
  dplyr::mutate(final_value = case_when(is.na(final_value) ~ value, TRUE ~ final_value)) %>%
  dplyr::select(Var1, Var2, value = final_value)


# Convert long table back to square matrix
master_dist <- reshape2::acast(final_long_dist, Var1 ~ Var2, value.var = 'value')

# Build UPGMA tree and save
tree_combined <- phangorn::upgma(master_dist)

ape::write.tree(tree_combined, file = "./trees/ITS2_28S.tre")

tree_combined_nj <- ape::nj(as.dist(master_dist))

# Write the tree down 
ape::write.tree(tree_combined_nj, file = "./trees/ITS2_28S_nj.tre")


# Get tips that belong to Symbiodinium
symbio_tips <- data.frame(OTU = tree_combined_nj$tip.label) %>%
  dplyr::left_join(
    phyloseq::psmelt(phyloseq_symbio) %>%
      dplyr::select(OTU, Genus, Species) %>%
      dplyr::distinct(),
    by = "OTU"
  )  %>%
  dplyr::filter(Genus == "Symbiodinium") %>%
  dplyr::pull(OTU)

# Reroot the NJ tree on these taxa (if multiple tips, midpoint them as a clade)
tree_combined_nj_rooted <- ape::root(tree_combined_nj, outgroup = symbio_tips, resolve.root = TRUE)
ape::write.tree(tree_combined_nj_rooted, file = "./trees/ITS2_28S_nj_rooted.tre")

# Update phyloseq object 
# phyloseq_symbio <- phyloseq::merge_phyloseq(phyloseq_symbio, phyloseq::phy_tree(tree))
```


Check how the tree looks like
```{r}
tree_combined <- ape::read.tree("./trees/ITS2_28S.tre")
tree_combined_nj <- ape::read.tree("./trees/ITS2_28S_nj.tre")
tree_combined_nj_rooted <- ape::read.tree("./trees/ITS2_28S_nj_rooted.tre")

tip_metadata <- data.frame(OTU = tree_combined$tip.label) %>%
  dplyr::left_join(
    phyloseq::psmelt(phyloseq_symbio) %>%
      dplyr::select(OTU, Genus, Label_match) %>%
      dplyr::distinct(),
    by = "OTU"
  ) %>%
  dplyr::mutate(tip_label = Label_match)  # ASV + species

# Compute a larger x-axis limit
max_x <- max(ggtree::ggtree(tree_combined )$data$x)  # current tree tip x positions
extra_space <- 0.3 * max_x                  # add 50% more space for labels

ITS2_28S_plt <- ggtree::ggtree(tree_combined) %<+% tip_metadata +
  ggtree::geom_tippoint(aes(color = Genus), size = 4, shape = 15) +
  ggtree::geom_tiplab(aes(label = tip_label), size = 4, align = TRUE, linetype = NA, offset = 0.005) +
  ggplot2::scale_color_manual(values = Symbiodiniaceae_color_palette) +
  ggplot2::xlim(0, max_x + extra_space)   # extend x-axis for long labels

ggplot2::ggsave("tree_plots/ITS2_28S_upgma.png", plot = ITS2_28S_plt,
                width = 30, height = 20, dpi = 300)


# Plot rooted
#tree_combined_nj_rooted$root.edge <- 0.05
tree_combined_nj_rooted_plt <- ggtree::ggtree(tree_combined_nj_rooted) %<+% tip_metadata +
  ggtree::geom_tippoint(aes(fill = Genus), size = 4, shape = 22, offset = 0.0005, color = "grey") +
  ggtree::geom_tiplab(aes(label = tip_label), size = 4, align = FALSE, offset = 0.0005) +
  ggplot2::scale_fill_manual(values = Symbiodiniaceae_color_palette)
  #ggplot2::scale_color_manual(values = Symbiodiniaceae_color_palette) #+ geom_rootedge()


ggplot2::ggsave("./tree_plots/28S_ITS2_tree_combined_nj_rooted.png", plot = tree_combined_nj_rooted_plt,
                width = 30, height = 20, dpi = 300)
```

# Create k-mer tree
Alignment-free method, uses k-mers: alignment-free, fast, useful for very diverse sequences where alignment is difficult (ITS2 from the whole Symbiodiniaceae family).

The code snippet below was modified from https://github.com/nitschkematthew/Free_living_Symbiodiniaceae_HI/blob/master/R/community_analysis/community_analysis.Rmd and comments were added together with ChatGPT.

```{r}
# Helper function
# Input: Biostrings::DNAStringSet object (output from phyloseq::refseq())
# Output: a data.frame with two columns: names — the sequence names (tip/ASV IDs),seqs — the sequences as plain character strings (via paste()).

DNAStringSet_to_df <- function(DNAStringSet){
  seq_df <- data.frame(names = names(DNAStringSet),
                       seqs = paste(DNAStringSet))
  return(seq_df)
}


# Helper function 
# Input: a data.frame with a column of sequences (default column name "seqs") and a column of names (default "names").
# Output: a Biostrings::DNAStringSet

df_to_DNAStringset <- function(df, seqs = "seqs", names = "names"){
  DNAstr <- DNAStringSet(df[[seqs]])
  names(DNAstr) <- df[[names]]
  return(DNAstr)
}


# Helper function 
# Coerces sequences into ape::DNAbin format (the “raw-byte” format used by many phylogenetics functions).
# The coercion function is ape::as.DNAbin() (i.e. as.DNAbin() comes from ape).
# ape::as.DNAbin() accepts many sequence types (including Biostrings::DNAStringSet or character lists) and returns an object of class DNAbin.
# Many k-mer / distance functions accept DNAbin inputs.

DNAStringSet_to_DNAbin <- function(DNAStringSet){
  DNAbin <- ape::as.DNAbin(DNAStringSet)
  return(DNAbin)
}


# Get sequences associated with phyloseq object (ASVs)
# Turn the into a data.frame ASVs_df with columns names and seqs.
# Check (should be "DNAStringSet")
# class(phyloseq::refseq(phyloseq_symbio))

ASVs_df <- refseq(phyloseq_symbio) %>%
    DNAStringSet_to_df()

# build an alignment-free k-mer distance matrix
# Function: kmer::kdistance() computes an n × n k-mer distance matrix (class "dist") for all sequences using k-mer counts, the k-mer length is controlled by k = 7 sets.
# method = "edgar" chooses the Edgar (2004) distance measure 

kdist <- ASVs_df %>%
  df_to_DNAStringset() %>%   #(user-defined) converts the ASVs data.frame back into a Biostrings::DNAStringSet
  DNAStringSet_to_DNAbin() %>%  
  # (user-defined wrapper for ape::as.DNAbin()) converts the DNAStringSet into a DNAbin object (the format expected by the kmer package).
  kmer::kdistance(k = 7, residues = "DNA", method = "edgar") %>%
  as.matrix()  # Converts the dist object to a full square numeric matrix number_of_ASVs × number_of_ASV

# build a tree using UPGMA (unweighted pair-group method with arithmetic mean)
# produces an ultrametric tree (equal root-to-tip heights)

tree_kmer <- phangorn::upgma(kdist)
tree_kmer_nj <- ape::nj(as.dist(kdist))
# Write the tree down 
ape::write.tree(tree_kmer, file = "./trees/ITS2_kmer.tre")
ape::write.tree(tree_kmer_nj, file = "./trees/ITS2_kmer_nj.tre")

# Get tips that belong to Symbiodinium
symbio_tips <- data.frame(OTU = tree_kmer_nj$tip.label) %>%
  dplyr::left_join(
    phyloseq::psmelt(phyloseq_symbio) %>%
      dplyr::select(OTU, Genus, Species) %>%
      dplyr::distinct(),
    by = "OTU"
  )  %>%
  dplyr::filter(Genus == "Symbiodinium") %>%
  dplyr::pull(OTU)

# Reroot the tree on these taxa (if multiple tips, midpoint them as a clade)
tree_kmer_nj_rooted <- ape::root(tree_kmer_nj, outgroup = symbio_tips, resolve.root = TRUE)
  #midpoint(tree_kmer_nj)
ape::write.tree(tree_kmer_nj_rooted, file = "./trees/ITS2_kmer_nj_rooted.tre")

# Check 
setdiff(tree_kmer_nj_rooted$tip.label, phyloseq::taxa_names(phyloseq_symbio))  # should be character(0)
setdiff(phyloseq::taxa_names(phyloseq_symbio), tree_kmer_nj_rooted$tip.label)  # should be character(0)
```


## Visualize k-mer tree

The code for the tree visualisation was written with the help of ChatGPT.
```{r}
tree_kmer <- ape::read.tree("./trees/ITS2_kmer.tre")
tree_kmer_nj_rooted <- ape::read.tree("./trees/ITS2_kmer_nj_rooted.tre")


tip_metadata <- data.frame(OTU = tree_kmer$tip.label) %>%
  dplyr::left_join(
    phyloseq::psmelt(phyloseq_symbio) %>%
      dplyr::select(OTU, Genus, Label_match) %>%
      dplyr::distinct(),
    by = "OTU"
  ) %>%
  dplyr::mutate(tip_label = Label_match)  #

# Compute a larger x-axis limit
max_x_kmer <- max(ggtree::ggtree(tree_kmer)$data$x)  # current tree tip x positions
extra_space_kmer <- 0.3 * max_x_kmer                  # add 50% more space for labels

ITS2_kmer_plt <- ggtree::ggtree(tree_kmer) %<+% tip_metadata +
  ggtree::geom_tippoint(aes(color = Genus), size = 4, shape = 15)  +
  ggtree::geom_tiplab(aes(label = tip_label), size = 4, align = TRUE, linetype = NA, offset = 0.005) +
  ggplot2::scale_color_manual(values = Symbiodiniaceae_color_palette) +
  ggplot2::xlim(0, max_x_kmer + extra_space_kmer)  # extend x-axis for long labels

ggplot2::ggsave("./tree_plots/ITS2_kmer_upgma.png", plot = ITS2_kmer_plt,
                width = 30, height = 20, dpi = 300)

# Plot as rooted 
#tree_kmer_nj_rooted$root.edge <- 0.05
ITS2_kmer_nj_rooted_plt <- ggtree::ggtree(tree_kmer_nj_rooted) %<+% tip_metadata +
  ggtree::geom_tippoint(aes(fill = Genus), size = 4, shape = 22, offset = 0.0005, color = "grey") +
  ggtree::geom_tiplab(aes(label = tip_label), size = 4, align = FALSE, offset = 0.0005) +
  ggplot2::scale_fill_manual(values = Symbiodiniaceae_color_palette)
  #ggplot2::scale_color_manual(values = Symbiodiniaceae_color_palette)# + geom_rootedge()


ggplot2::ggsave("./tree_plots/ITS2_kmer_nj_rooted.png", plot = ITS2_kmer_nj_rooted_plt ,
                width = 30, height = 20, dpi = 300)
```

Inspect the differences in the two UPGMA trees

The code snippet below was modified from https://github.com/nitschkematthew/Free_living_Symbiodiniaceae_HI/blob/master/R/community_analysis/community_analysis.Rmd together with ChatGPT.

```{r}
# Read trees
ITS2_28S_tree <- read.tree("./trees/ITS2_28S.tre")
ITS2_kmer_tree <- read.tree("./trees/ITS2_kmer.tre")

# Convert to dendrograms
dnd1 <- as.dendrogram(ITS2_28S_tree)
dnd2 <- as.dendrogram(ITS2_kmer_tree)

# Mapping ASV -> Genus
tip_genus <- phyloseq::psmelt(phyloseq_symbio) %>%
  select(OTU, Genus) %>%
  distinct()

# Match colors the palette
label_colors <- setNames(Symbiodiniaceae_color_palette[tip_genus$Genus], tip_genus$OTU)

# Apply to dendrograms
dnd1 <- dendextend::set(dnd1, "labels_col", label_colors[labels(dnd1)])
dnd2 <- dendextend::set(dnd2, "labels_col", label_colors[labels(dnd2)])

# Combine in list
dndlist <- dendlist(dnd1, dnd2)

# Save to PNG with colored ASVs and labeled trees
png("./tree_plots/ITS2_tanglegram_colored.png", width = 6000, height = 4000, res = 300)
tanglegram(
  dndlist,
  fast = TRUE,
  margin_inner = 5,
  main_left = "28S+ITS2 UPGMA tree",
  main_right = "ITS2 k-mer UPGMA tree"
)

dev.off()

```
# Make FastTree 
Get an alignment-based ML tree with FastTree
```
> cd fasttree/
> mafft --auto ../input/ASV_Symbiodiniaceae_filtered.fasta >ASV_Symbio_filt_mafft_aln.fasta
# MAFFT v7.505 (2022/Apr/10)
> trimal -in ASV_Symbio_filt_mafft_aln.fasta \
      -out ASV_Symbio_filt_mafft_aln_trim.fasta \
      -automated1 \
      -htmlout ASV_Symbio_filt_mafft_aln_trim.html
# trimAl v1.5.rev0 build[2024-05-27]
> FastTree -gtr -nt ASV_Symbio_filt_mafft_aln_trim.fasta > ASV_Symbio_filt_mafft_aln_trim.nwk
FastTree Version 2.1.11 Double precision (No SSE3)
Nucleotide distances: Jukes-Cantor Joins: balanced Support: SH-like 1000
Search: Normal +NNI +SPR (2 rounds range 10) +ML-NNI opt-each=1
TopHits: 1.00*sqrtN close=default refresh=0.80
ML Model: Generalized Time-Reversible, CAT approximation with 20 rate categories
Total time: 1.38 seconds Unique: 109/111 Bad splits: 0/106ternal splits
For comparison: 
> #FastTree -gtr -nt ASV_Symbio_filt_mafft_aln.fasta > ASV_Symbio_filt_mafft.nwk

```
```{r}
combined_tree <- read.tree("./trees/ITS2_28S_nj_rooted.tre")
ITS2_kmer_tree <- read.tree("./trees/ITS2_kmer_nj_rooted.tre")
FastTree_tree <- read.tree("./fasttree/ASV_Symbio_filt_mafft_aln_trim.nwk")

# Get tips that belong to Symbiodinium
symbio_tips <- data.frame(OTU = FastTree_tree$tip.label) %>%
  dplyr::left_join(
    phyloseq::psmelt(phyloseq_symbio) %>%
      dplyr::select(OTU, Genus, Label_match) %>%
      dplyr::distinct(),
    by = "OTU"
  )  %>%
  dplyr::filter(Genus == "Symbiodinium") %>%
  dplyr::pull(OTU)

# Check 
setdiff(FastTree_tree$tip.label, phyloseq::taxa_names(phyloseq_symbio))  # should be character(0)
setdiff(phyloseq::taxa_names(phyloseq_symbio), FastTree_tree$tip.label)  # should be character(0)

# Reroot the tree on these taxa (if multiple tips, midpoint them as a clade)
FastTree_rooted <- midpoint(FastTree_tree)
#FastTree_rooted <- ape::root(FastTree_tree, outgroup = symbio_tips, resolve.root = TRUE)
ape::write.tree(FastTree_rooted, file = "./trees/FastTree_rooted.tre")

```
Visualise all the trees 
```{r}
tip_metadata <- data.frame(OTU = FastTree_rooted$tip.label) %>%
  dplyr::left_join(
    phyloseq::psmelt(phyloseq_symbio) %>%
      dplyr::select(OTU, Genus, Label_match) %>%
      dplyr::distinct(),
    by = "OTU"
  ) %>%
  dplyr::mutate(tip_label = Label_match)  

# FastTree

max_x <- max(ggtree::ggtree(FastTree_rooted)$data$x)  # current tree tip x positions
extra_space <- 0.2 * max_x              

FastTree_rooted_plt <- ggtree(FastTree_rooted) %<+% tip_metadata +
  ggtree::geom_tippoint(
    aes(x = x + 0.01, fill = Genus),  # manually shift points right
    size = 5, shape = 22, color = "grey"
  ) +
  ggtree::geom_tiplab(
    aes(label = tip_label),
    size = 4,
    align = FALSE,
    offset = 0.02
  ) +
  ggplot2::scale_fill_manual(values = Symbiodiniaceae_color_palette, 
                             labels = Symbiodiniaceae_genera_labels, 
                             guide = guide_legend(
    override.aes = list(size = 10) ))+
  labs(title="FastTree filtered rooted") +
  theme(
    plot.title = element_text(size = 40), 
    legend.position = c(0.3, 0.7),
    legend.justification = c("right", "bottom"),
    legend.key.size = unit(1, "cm"),
    legend.text = element_text(size = 30),
    legend.title = element_text(size = 35)
  ) +
  ggplot2::xlim(0, max_x + extra_space) +
  ggtree::geom_treescale(x = 1, y = -1, linesize = 0.5, fontsize = 10)  


ggplot2::ggsave("./tree_plots/Compare_FastTree_rooted.png", plot = FastTree_rooted_plt,
                width = 15, height = 20, dpi = 300)

max_x <- max(ggtree::ggtree(combined_tree)$data$x)  # current tree tip x positions
extra_space <- 0.3 * max_x              

#combined_tree
combined_tree_plt <- ggtree::ggtree(combined_tree) %<+% tip_metadata +
  ggtree::geom_tippoint(
    aes(x = x + 0.01, fill = Genus),  # manually shift points right
    size = 5, shape = 22, color = "grey"
  ) +
  ggtree::geom_tiplab(
    aes(label = tip_label),
    size = 4,
    align = FALSE,
    offset = 0.02
  ) +
  ggplot2::scale_fill_manual(values = Symbiodiniaceae_color_palette, 
                             labels = Symbiodiniaceae_genera_labels, 
                             guide = guide_legend(
    override.aes = list(size = 10) ))+
  labs(title="Combined 28S + ITS2 tree") +
  theme(
    plot.title = element_text(size = 40), 
    legend.position = c(0.95, 0),
    legend.justification = c("right", "bottom"),
    legend.key.size = unit(1, "cm"),
    legend.text = element_text(size = 30),
    legend.title = element_text(size = 35)
  ) +
  ggplot2::xlim(0, max_x + extra_space) +
  ggtree::geom_treescale(x = 1, y = -1, linesize = 0.5, fontsize = 10)

ggplot2::ggsave("./tree_plots/Compare_combined_tree.png", plot = combined_tree_plt,
                width = 15, height = 20, dpi = 300)


# K-mer
max_x <- max(ggtree::ggtree(ITS2_kmer_tree)$data$x)  # current tree tip x positions
extra_space <- 0.3 * max_x  

ITS2_kmer_tree_plt <- ggtree::ggtree(ITS2_kmer_tree) %<+% tip_metadata +
    ggtree::geom_tippoint(
    aes(x = x + 0.01, fill = Genus),  # manually shift points right
    size = 5, shape = 22, color = "grey"
  ) +
  ggtree::geom_tiplab(
    aes(label = tip_label),
    size = 4,
    align = FALSE,
    offset = 0.02
  ) +
  ggplot2::scale_fill_manual(values = Symbiodiniaceae_color_palette, 
                             labels = Symbiodiniaceae_genera_labels, 
                             guide = guide_legend(
    override.aes = list(size = 10) ))+
  labs(title="ITS2 kmer tree") +
  theme(
    plot.title = element_text(size = 40), 
    legend.position = c(0.95, 0),
    legend.justification = c("right", "bottom"),
    legend.key.size = unit(1, "cm"),
    legend.text = element_text(size = 30),
    legend.title = element_text(size = 35)
  ) +
  ggplot2::xlim(0, max_x + extra_space) +
  ggtree::geom_treescale(x = 1, y = -1, linesize = 0.5, fontsize = 10) 


ggplot2::ggsave("./tree_plots/Compare_ITS2_kmer_tree_plt.png", plot = ITS2_kmer_tree_plt,
                width = 15, height = 20, dpi = 300)


```

# Make a tree for the raw sequences: 

```
> cd fasttree/
> mafft --auto ../input/ASV_Symbiodiniaceae_unfiltered.fasta >ASV_Symbio_unfilt_mafft_aln.fasta
# MAFFT v7.505 (2022/Apr/10)
> trimal -in ASV_Symbio_unfilt_mafft_aln.fasta \
      -out ASV_Symbio_unfilt_mafft_aln_trim.fasta \
      -automated1 \
      -htmlout ASV_Symbio_unfilt_mafft_aln_trim.html
# trimAl v1.5.rev0 build[2024-05-27]
> FastTree -gtr -nt ASV_Symbio_unfilt_mafft_aln_trim.fasta > ASV_Symbio_unfilt_mafft_aln_trim.nwk
FastTree Version 2.1.11 Double precision (No SSE3)
Alignment: ASV_Symbio_unfilt_mafft_aln_trim.fasta
Nucleotide distances: Jukes-Cantor Joins: balanced Support: SH-like 1000
Search: Normal +NNI +SPR (2 rounds range 10) +ML-NNI opt-each=1
TopHits: 1.00*sqrtN close=default refresh=0.80
ML Model: Generalized Time-Reversible, CAT approximation with 20 rate categories
> #FastTree -gtr -nt ASV_Symbio_filt_mafft_aln.fasta > ASV_Symbio_filt_mafft.nwk

```

```{r}
FastTree_unfilt_tree <- read.tree("./fasttree/ASV_Symbio_unfilt_mafft_aln_trim.nwk")

# Get tips that belong to Symbiodinium
symbio_tips <- data.frame(OTU = FastTree_unfilt_tree$tip.label) %>%
  dplyr::left_join(
    phyloseq::psmelt(phyloseq_symbio_raw) %>%
      dplyr::select(OTU, Genus, Label_match) %>%
      dplyr::distinct(),
    by = "OTU"
  )  %>%
  dplyr::filter(Genus == "Symbiodinium") %>%
  dplyr::pull(OTU)

# Reroot the tree on these taxa (if multiple tips, midpoint them as a clade)
FastTree_unf_rooted <- midpoint(FastTree_unfilt_tree)
#FastTree_unf_rooted <- ape::root(FastTree_unfilt_tree, outgroup = symbio_tips, resolve.root = TRUE)
ape::write.tree(FastTree_unf_rooted, file = "./trees/FastTree_unfilt_rooted.tre")

dropped_otus <- setdiff(
  phyloseq::taxa_names(phyloseq_symbio_raw),
  phyloseq::taxa_names(phyloseq_symbio)
)


tip_metadata <- data.frame(OTU = FastTree_unf_rooted$tip.label) %>%
  dplyr::left_join(
    phyloseq::psmelt(phyloseq_symbio_raw) %>%
      dplyr::select(OTU, Genus, Label_match) %>%
      dplyr::distinct(),
    by = "OTU"
  ) %>%
  dplyr::mutate(
    tip_label = Label_match,
    filtered_out = ifelse(OTU %in% dropped_otus, TRUE, FALSE)
  )%>%
  dplyr::mutate(
    Genus = factor(
      Genus,
      levels = c("Cladocopium", "Halluxium", "Freudenthalidium", "clade_Fr4", "Fugacium", 
                   "clade_J", "clade_I", "Miliolidium", "Durusdinium", "Symbiodinium" )
    )
  )



# FastTree

max_x <- max(ggtree::ggtree(FastTree_unf_rooted)$data$x)  # current tree tip x positions
extra_space <- 0.2 * max_x              
thr <- 0.1 

FastTree_unf_rooted_plt <- ggtree(FastTree_unf_rooted) %<+% tip_metadata +
  ggtree::geom_tippoint(
    aes(x = x + 0.01, fill = Genus),  # manually shift points right
    size = 5, shape = 22, color = "grey"
  ) +
  ggtree::geom_tiplab(
    aes(label = ifelse(filtered_out, paste0(tip_label, "★"), tip_label), 
        color = ifelse(filtered_out, "Filtered", "Normal")),
  size = 4,
  align = FALSE,
  offset = 0.02
  ) +
  scale_color_manual(
    values = c("Filtered" = "darkorange", "Normal" = "black"), 
    guide = "none"  # hide legend for text colors
  )+
  ggplot2::scale_fill_manual(values = Symbiodiniaceae_color_palette, 
                             labels = Symbiodiniaceae_genera_labels, 
                             guide = guide_legend(
    override.aes = list(size = 10) ))+
  labs(title="") +
  theme(
    plot.title = element_text(size = 40), 
    legend.position = c(0.3, 0.8),
    legend.justification = c("right", "bottom"),
    legend.key.size = unit(1, "cm"),
    legend.text = element_text(size = 30),
    legend.title = element_blank() #element_text(size = 35)
  ) +
  ggplot2::xlim(0, max_x + extra_space) +
  ggtree::geom_treescale(x = 0, y = 0, linesize = 0.5, fontsize = 10, width = 0.1) 

ggplot2::ggsave("./tree_plots/Compare_FastTree_unf_rooted.png", plot = FastTree_unf_rooted_plt,
                width = 15, height = 24, dpi = 300)

```


Checks
This chunk of code was generated with ChatGPT
```{r}
# FastTree puts local support in node.label (0-1 or 0-100 depending on build)
common_tips <- intersect(FastTree_unfilt_tree$tip.label, FastTree_tree$tip.label)

t_unf_pruned <- ape::keep.tip(FastTree_unfilt_tree, common_tips)
t_fil_pruned <- ape::keep.tip(FastTree_tree, common_tips)

# compare
rf <- phangorn::RF.dist(t_unf_pruned, t_fil_pruned, normalize = TRUE)
m  <- vegan::mantel(as.dist(cophenetic(t_unf_pruned)),
                    as.dist(cophenetic(t_fil_pruned)),
                    permutations = 999)
rf; m$statistic; m$signif
```

Make tiny genus tree if topology of filtered and unfiltered tree differ
This chunk of code was mostly generated with ChatGPT
```{r}
# helper to flatten weird columns
flatten_col <- function(col) {
  # Rle -> vector
  if (inherits(col, "Rle")) col <- as.vector(col)
  # list-column -> flatten each element to a string
  if (is.list(col)) {
    v <- sapply(col, function(x) {
      if (is.null(x)) return(NA_character_)
      if (length(x) == 0) return(NA_character_)
      # if atomic (character/numeric), paste, otherwise take first element
      if (is.atomic(x)) return(paste(as.character(x), collapse = ";"))
      else return(as.character(x[[1]]))
    }, USE.NAMES = FALSE)
    return(v)
  }
  # factor -> character, otherwise coerce to character
  if (is.factor(col)) return(as.character(col))
  return(as.character(col))
}

# Safe make_genus_tree
make_genus_tree_safe <- function(phy, tip_metadata, rep_method = c("first", "most_abundant")) {
  rep_method <- match.arg(rep_method)
  # make plain data.frame (avoid tibble quirks)
  md <- as.data.frame(tip_metadata, stringsAsFactors = FALSE)
  
  # Ensure the three relevant columns exist (OTU, Genus, Label_match)
  for (cname in c("OTU", "Genus", "Label_match")) {
    if (! (cname %in% colnames(md)) ) {
      md[[cname]] <- NA_character_
    }
  }
  
  # Flatten these columns robustly
  md$OTU         <- flatten_col(md$OTU)
  md$Genus       <- flatten_col(md$Genus)
  md$Label_match <- flatten_col(md$Label_match)
  
  # Keep only rows that correspond to tips actually in the tree
  md <- md %>% filter(!is.na(OTU) & OTU %in% phy$tip.label)
  if (nrow(md) == 0) stop("No metadata rows match tree tip labels after flattening.")
  
  md$Genus[is.na(md$Genus) | md$Genus == ""] <- "Unknown"
  
  # pick representative OTU per genus
  if (rep_method == "first") {
    reps_df <- md %>%
      group_by(Genus) %>%
      summarize(OTU = OTU[1], n_asvs = n(), .groups = "drop")
  } else {
    # most_abundant: requires 'abundance' column; fallback to 'first' if missing
    if (!("abundance" %in% colnames(md))) {
      warning("'abundance' column missing; falling back to rep_method = 'first'")
      reps_df <- md %>%
        group_by(Genus) %>%
        summarize(OTU = OTU[1], n_asvs = n(), .groups = "drop")
    } else {
      reps_df <- md %>%
        group_by(Genus) %>%
        arrange(desc(abundance)) %>%
        summarize(OTU = OTU[1], n_asvs = n(), .groups = "drop")
    }
  }
  
  # ensure chosen representatives are actually in the phy tree
  reps_df <- reps_df %>% filter(OTU %in% phy$tip.label)
  if (nrow(reps_df) == 0) stop("After filtering, none of the representative OTUs are in the tree.")
  
  # tips to drop: everything in tree that is not a representative OTU
  reps <- reps_df$OTU
  tips_to_drop <- setdiff(phy$tip.label, reps)
  phy_genus <- ape::drop.tip(phy, tips_to_drop)
  
  # rename remaining tips to the corresponding genus
  # build mapping in the order of phy_genus$tip.label
  map_df <- reps_df[match(phy_genus$tip.label, reps_df$OTU), , drop = FALSE]
  # safety check: ensure no NA OTU mapping
  if (any(is.na(map_df$Genus))) stop("Mapping failed: some remaining tips have no genus mapping.")
  phy_genus$tip.label <- map_df$Genus
  
  # tidy meta for genus tips
  tip_meta_genus <- data.frame(Genus = phy_genus$tip.label, n_asvs = map_df$n_asvs, stringsAsFactors = FALSE)
  
  return(list(phy_genus = phy_genus, tip_meta_genus = tip_meta_genus, reps_df = reps_df, md_flat = md))
}


res <- make_genus_tree_safe(FastTree_rooted, tip_metadata, rep_method = "first")
phy_genus <- res$phy_genus
tip_meta_genus <- res$tip_meta_genus

tip_meta_genus <- tip_meta_genus %>%
  dplyr::rename(label = Genus)

# plot tree to identify node numbers interactively
ggtree(phy_genus) + 
  geom_text2(aes(label = node), hjust = -0.3) +geom_tiplab(aes(label = label), size = 3, offset = 0.02) 

# once you know which two nodes you want to flip:
p <- ggtree(phy_genus)

# flip the children of node 15 (or explicitly between 16 and 17)
p_flipped <- flip(p, node1 = 1, node2 = 2)
#p_flipped <- flip(p_flipped, node1 = 10, node2 = 9)
#p_flipped <- flip(p_flipped, node1 = 1, node2 = 2)
# plot

p_genus <- p_flipped %<+% tip_meta_genus +
  geom_tippoint(aes(fill = label, size = n_asvs), shape = 22, color = "grey", show.legend = FALSE) +
  geom_tiplab(aes(label = label), size = 8, offset = 0.02) +
  scale_size_continuous(name = "ASVs per genus") +
  scale_fill_manual(values = Symbiodiniaceae_color_palette) +
  theme(legend.position = "bottom") +
  ggplot2::xlim(0, 1) +
  ggtree::geom_treescale(x = 0, y = -0.1, linesize = 0.5, fontsize = 5, width = 0.1) 

p_genus  
```

Make a big tree (unfiltered with filtered inset)
```{r}
library(patchwork)

Inset_plt <- FastTree_unf_rooted_plt + inset_element(p_genus,  left = 0, bottom = 0.7, right = 0.45, top = 1)
ggplot2::ggsave("./tree_plots/INSET.png", plot =Inset_plt,
                width = 15, height = 26, dpi = 300)

ggsave_clean("./tree_plots/INSET.svg", plot =Inset_plt,
                width = 15, height = 26, dpi = 300)
```

# Make a tree for pre-lulu sequences

```
> cd fasttree/
> mafft --auto ../input/ASV_Symbiodiniaceae_prelulu.fasta >ASV_Symbio_prelulu_mafft_aln.fasta
# MAFFT v7.505 (2022/Apr/10)
> trimal -in ASV_Symbio_prelulu_mafft_aln.fasta \
      -out ASV_Symbio_prelulu_mafft_aln_trim.fasta \
      -automated1 \
      -htmlout ASV_Symbio_prelulu_mafft_aln_trim.html
# trimAl v1.5.rev0 build[2024-05-27]
> FastTree -gtr -nt ASV_Symbio_prelulu_mafft_aln_trim.fasta > ASV_Symbio_prelulu_mafft_aln_trim.nwk
FastTree Version 2.1.11 Double precision (No SSE3)
Alignment: ASV_Symbio_prelulu_mafft_aln_trim.fasta
Nucleotide distances: Jukes-Cantor Joins: balanced Support: SH-like 1000
Search: Normal +NNI +SPR (2 rounds range 10) +ML-NNI opt-each=1
TopHits: 1.00*sqrtN close=default refresh=0.80
ML Model: Generalized Time-Reversible, CAT approximation with 20 rate categories

```
Visualise pre-lulu tree
```{r}
FastTree_prelulu <- read.tree("./fasttree/ASV_Symbio_prelulu_mafft_aln_trim.nwk")

# Get tips that belong to Symbiodinium
symbio_tips <- data.frame(OTU = FastTree_prelulu$tip.label) %>%
  dplyr::left_join(
    phyloseq::psmelt(phyloseq_symbio_lulu) %>%
      dplyr::select(OTU, Genus, Species) %>%
      dplyr::distinct(),
    by = "OTU"
  )  %>%
  dplyr::filter(Genus == "Symbiodinium") %>%
  dplyr::pull(OTU)

# Reroot the tree on these taxa (if multiple tips, midpoint them as a clade)
FastTree_prelulu_rooted <- midpoint(FastTree_prelulu)
#FastTree_prelulu_rooted <- ape::root(FastTree_prelulu, outgroup = symbio_tips, resolve.root = TRUE)
#ape::write.tree(FastTree_unf_rooted, file = "./trees/FastTree_unfilt_rooted.tre")

dropped_otus <- setdiff(
  phyloseq::taxa_names(phyloseq_symbio_lulu),
  phyloseq::taxa_names(phyloseq_symbio_raw)
)


tip_metadata <- data.frame(OTU = FastTree_prelulu_rooted$tip.label) %>%
  dplyr::left_join(
    phyloseq::psmelt(phyloseq_symbio_lulu) %>%
      dplyr::select(OTU, Genus, Species) %>%
      dplyr::distinct(),
    by = "OTU"
  ) %>%
  dplyr::mutate(
    tip_label = OTU,
    filtered_out = ifelse(OTU %in% dropped_otus, TRUE, FALSE)
  )%>%
  dplyr::mutate(
    Genus = factor(
      Genus,
      levels = c("Cladocopium", "Halluxium", "Fugacium", "Freudenthalidium", "Freudenthalidium_blastn",
                  "clade_Fr4", "clade_J", "clade_I", "Miliolidium", "Durusdinium", "Symbiodinium" )
    )
  )



# FastTree

max_x <- max(ggtree::ggtree(FastTree_prelulu_rooted)$data$x)  # current tree tip x positions
extra_space <- 0.2 * max_x              
thr <- 0.1 

FastTree_prelulu_rooted_plt <- ggtree(FastTree_prelulu_rooted) %<+% tip_metadata +
  ggtree::geom_tippoint(
    aes(x = x + 0.002, fill = Genus),  # manually shift points right
    size = 2, shape = 22, color = "grey"
  ) +
  ggtree::geom_tiplab(
    aes(label = ifelse(filtered_out, paste0(tip_label, "★"), tip_label), 
        color = ifelse(filtered_out, "Filtered", "Normal")),
  size = 2,
  align = FALSE,
  offset = 0.01
  ) +
  scale_color_manual(
    values = c("Filtered" = "darkorange", "Normal" = "black"), 
    guide = "none"  # hide legend for text colors
  )+
  ggplot2::scale_fill_manual(values = Symbiodiniaceae_color_palette, 
                             labels = Symbiodiniaceae_genera_labels, 
                             guide = guide_legend(
    override.aes = list(size = 8) ))+
  labs(title="FastTree, ASVs before lulu, orange - dropped after lulu") +
  theme(
    plot.title = element_text(size = 40), 
    legend.position = c(0.2, 0.7),
    legend.justification = c("right", "bottom"),
    legend.key.size = unit(1, "cm"),
    legend.text = element_text(size = 20),
    legend.title = element_blank() 
  ) +
  ggplot2::xlim(0, max_x + extra_space) +
  ggtree::geom_treescale(x = 0, y = -0.1, linesize = 0.5, fontsize = 10, width = 0.1) 

ggplot2::ggsave("./tree_plots/LULU.png", plot = FastTree_prelulu_rooted_plt,
                width = 15, height = 30, dpi = 300)
```

```{r}

```

